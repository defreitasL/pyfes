#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by Grako.
#
#    https://pypi.python.org/pypi/grako/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import print_function, division, absolute_import, unicode_literals

from grako.buffering import Buffer
from grako.parsing import graken, Parser
from grako.util import re, RE_FLAGS, generic_main  # noqa


__all__ = [
    'CqlParser',
    'CqlSemantics',
    'main'
]

KEYWORDS = set([])


class CqlBuffer(Buffer):
    def __init__(
        self,
        text,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re=None,
        ignorecase=None,
        namechars='',
        **kwargs
    ):
        super(CqlBuffer, self).__init__(
            text,
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            namechars=namechars,
            **kwargs
        )


class CqlParser(Parser):
    def __init__(
        self,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re=None,
        ignorecase=None,
        left_recursion=False,
        parseinfo=True,
        keywords=None,
        namechars='',
        buffer_class=CqlBuffer,
        **kwargs
    ):
        if keywords is None:
            keywords = KEYWORDS
        super(CqlParser, self).__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            left_recursion=left_recursion,
            parseinfo=parseinfo,
            keywords=keywords,
            namechars=namechars,
            buffer_class=buffer_class,
            **kwargs
        )

    @graken()
    def _sequence_of_search_conditions_(self):
        self._search_condition_()
        with self._optional():
            self._token(';')
            self._search_condition_()

    @graken()
    def _search_condition_(self):

        def sep0():
            self._token('OR')

        def block0():
            self._boolean_term_()
        self._positive_closure(block0, sep=sep0)

    @graken()
    def _boolean_term_(self):

        def sep0():
            self._token('AND')

        def block0():
            self._boolean_factor_()
        self._positive_closure(block0, sep=sep0)

    @graken()
    def _boolean_factor_(self):
        with self._optional():
            self._token('NOT')
        self._boolean_primary_()

    @graken()
    def _boolean_primary_(self):
        with self._choice():
            with self._option():
                self._predicate_()
            with self._option():
                self._routine_invocation_()
            self._error('no available options')

    @graken()
    def _predicate_(self):
        with self._choice():
            with self._option():
                self._comparison_predicate_()
            with self._option():
                self._text_predicate_()
            with self._option():
                self._null_predicate_()
            with self._option():
                self._temporal_predicate_()
            with self._option():
                self._existence_predicate_()
            with self._option():
                self._between_predicate_()
            with self._option():
                self._include_exclude_predicate_()
            self._error('no available options')

    @graken()
    def _existence_predicate_(self):
        with self._choice():
            with self._option():
                self._attribute_name_()
                self._token('EXISTS')
            with self._option():
                self._attribute_name_()
                self._token('DOES-NOT-EXIST')
            self._error('no available options')

    @graken()
    def _comparison_predicate_(self):
        self._attribute_name_()
        self._comp_op_()
        self._expression_()

    @graken()
    def _comp_op_(self):
        with self._choice():
            with self._option():
                self._equals_operator_()
            with self._option():
                self._not_equals_operator_()
            with self._option():
                self._less_than_operator_()
            with self._option():
                self._greater_than_operator_()
            with self._option():
                self._less_than_or_equals_operator_()
            with self._option():
                self._greater_than_or_equals_operator_()
            self._error('no available options')

    @graken()
    def _text_predicate_(self):
        self._attribute_name_()
        with self._optional():
            self._token('NOT')
        self._token('LIKE')
        self._character_pattern_()

    @graken()
    def _character_pattern_(self):
        self._character_string_literal_()

    @graken()
    def _null_predicate_(self):
        self._attribute_name_()
        self._token('IS')
        with self._optional():
            self._token('NOT')
        self._token('NULL')

    @graken()
    def _between_predicate_(self):
        self._attribute_name_()
        with self._optional():
            self._token('NOT')
        self._token('BETWEEN')
        self._literal_()
        self._token('AND')
        self._literal_()

    @graken()
    def _temporal_predicate_(self):
        with self._choice():
            with self._option():
                self._attribute_name_()
                self._token('BEFORE')
                self._date_time_expression_()
            with self._option():
                self._attribute_name_()
                self._token('BEFORE OR DURING')
                self._temporal_period_()
            with self._option():
                self._attribute_name_()
                self._token('DURING')
                self._temporal_period_()
            with self._option():
                self._attribute_name_()
                self._token('DURING OR AFTER')
                self._temporal_period_()
            with self._option():
                self._attribute_name_()
                self._token('AFTER')
                self._date_time_expression_()
            self._error('no available options')

    @graken()
    def _date_time_expression_(self):
        with self._choice():
            with self._option():
                self._date_time_()
            with self._option():
                self._temporal_period_()
            self._error('no available options')

    @graken()
    def _date_time_(self):
        self._full_date_()
        self._token('T')
        self._utc_time_()

    @graken()
    def _full_date_(self):
        self._date_year_()
        self._token('-')
        self._date_month_()
        self._token('-')
        self._date_day_()

    @graken()
    def _date_year_(self):
        self._digit_()
        self._digit_()
        self._digit_()
        self._digit_()

    @graken()
    def _date_month_(self):
        self._digit_()
        self._digit_()

    @graken()
    def _date_day_(self):
        self._digit_()
        self._digit_()

    @graken()
    def _utc_time_(self):
        self._time_hour_()
        self._token(':')
        self._time_minute_()
        self._token(':')
        self._time_second_()
        self._token('Z')

    @graken()
    def _time_hour_(self):
        self._digit_()
        self._digit_()

    @graken()
    def _time_minute_(self):
        self._digit_()
        self._digit_()

    @graken()
    def _time_second_(self):
        self._digit_()
        self._digit_()
        with self._optional():
            self._token('.')

            def block0():
                self._digit_()
            self._positive_closure(block0)

    @graken()
    def _duration_(self):
        with self._choice():
            with self._option():
                self._token('P')
                self._dur_date_()
            with self._option():
                self._token('T')
                self._dur_time_()
            self._error('no available options')

    @graken()
    def _dur_date_(self):
        with self._choice():
            with self._option():
                self._dur_day_()
            with self._option():
                self._dur_month_()
            with self._option():
                self._dur_year_()
                with self._optional():
                    self._dur_time_()
            self._error('no available options')

    @graken()
    def _dur_day_(self):

        def block0():
            self._digit_()
        self._positive_closure(block0)
        self._token('D')

    @graken()
    def _dur_month_(self):

        def block0():
            self._digit_()
        self._positive_closure(block0)
        self._token('M')
        with self._optional():
            self._dur_day_()

    @graken()
    def _dur_year_(self):

        def block0():
            self._digit_()
        self._positive_closure(block0)
        self._token('Y')
        with self._optional():
            self._dur_month_()

    @graken()
    def _dur_time_(self):
        with self._choice():
            with self._option():
                self._dur_hour_()
            with self._option():
                self._dur_minute_()
            with self._option():
                self._dur_second_()
            self._error('no available options')

    @graken()
    def _dur_hour_(self):

        def block0():
            self._digit_()
        self._positive_closure(block0)
        self._token('H')
        with self._optional():
            self._dur_minute_()

    @graken()
    def _dur_minute_(self):

        def block0():
            self._digit_()
        self._positive_closure(block0)
        self._token('M')
        with self._optional():
            self._dur_second_()

    @graken()
    def _dur_second_(self):

        def block0():
            self._digit_()
        self._positive_closure(block0)
        self._token('S')

    @graken()
    def _temporal_period_(self):
        with self._choice():
            with self._option():
                self._date_time_()
                self._token('/')
                self._date_time_()
            with self._option():
                self._date_time_()
                self._token('/')
                self._duration_()
            with self._option():
                self._duration_()
                self._token('/')
                self._date_time_()
            self._error('no available options')

    @graken()
    def _include_exclude_predicate_(self):
        with self._choice():
            with self._option():
                self._token('INCLUDE')
            with self._option():
                self._token('EXCLUDE')
            self._error('expecting one of: EXCLUDE INCLUDE')

    @graken()
    def _expression_(self):
        with self._choice():
            with self._option():
                self._function_()
            with self._option():
                self._literal_()
            with self._option():
                self._attribute_name_()
            self._error('no available options')

    @graken()
    def _addition_operator_(self):
        with self._choice():
            with self._option():
                self._plus_sign_()
            with self._option():
                self._minus_sign_()
            self._error('no available options')

    @graken()
    def _multiplication_operator_(self):
        with self._choice():
            with self._option():
                self._asterisk_()
            with self._option():
                self._solidus_()
            self._error('no available options')

    @graken()
    def _function_(self):
        self._identifier_()
        self._token('(')
        with self._optional():
            self._function_arguments_()
            with self._optional():

                def block0():
                    self._token(',')
                    self._function_arguments_()
                self._positive_closure(block0)
        self._token(')')

    @graken()
    def _function_arguments_(self):
        with self._choice():
            with self._option():
                self._literal_()
            with self._option():
                self._attribute_name_()
            with self._option():
                self._expression_()
            self._error('no available options')

    @graken()
    def _literal_(self):
        with self._choice():
            with self._option():
                self._signed_numeric_literal_()
            with self._option():
                self._general_literal_()
            self._error('no available options')

    @graken()
    def _signed_numeric_literal_(self):
        with self._optional():
            self._sign_()
        self._unsigned_numeric_literal_()

    @graken()
    def _general_literal_(self):
        with self._choice():
            with self._option():
                self._character_string_literal_()
            with self._option():
                self._boolean_literal_()
            self._error('no available options')

    @graken()
    def _boolean_literal_(self):
        with self._choice():
            with self._option():
                self._token('TRUE')
            with self._option():
                self._token('FALSE')
            with self._option():
                self._token('UNKNOWN')
            self._error('expecting one of: FALSE TRUE UNKNOWN')

    @graken()
    def _routine_invocation_(self):
        with self._choice():
            with self._option():
                self._geoop_name_()
                self._georoutine_argument_list_()
            with self._option():
                self._relgeoop_name_()
                self._relgeoop_argument_list_()
            with self._option():
                self._token('BBOX')
                self._bbox_argument_list_()
            self._error('no available options')

    @graken()
    def _routine_name_(self):
        self._attribute_name_()

    @graken()
    def _geoop_name_(self):
        with self._choice():
            with self._option():
                self._token('EQUALS')
            with self._option():
                self._token('DISJOINT')
            with self._option():
                self._token('INTERSECTS')
            with self._option():
                self._token('TOUCHES')
            with self._option():
                self._token('CROSSES')
            with self._option():
                self._token('WITHIN')
            with self._option():
                self._token('CONTAINS')
            with self._option():
                self._token('OVERLAPS')
            with self._option():
                self._token('RELATE')
            self._error('expecting one of: CONTAINS CROSSES DISJOINT EQUALS INTERSECTS OVERLAPS RELATE TOUCHES WITHIN')

    @graken()
    def _bbox_argument_list_(self):
        self._token('(')
        self._attribute_name_()
        self._token(',')
        self._min_X_()
        self._token(',')
        self._min_Y_()
        self._token(',')
        self._max_X_()
        self._token(',')
        self._max_Y_()
        with self._optional():
            self._token(',')
            self._crs_()
        self._token(')')

    @graken()
    def _min_X_(self):
        self._signed_numeric_literal_()

    @graken()
    def _min_Y_(self):
        self._signed_numeric_literal_()

    @graken()
    def _max_X_(self):
        self._signed_numeric_literal_()

    @graken()
    def _max_Y_(self):
        self._signed_numeric_literal_()

    @graken()
    def _crs_(self):
        self._empty_closure()

    @graken()
    def _relgeoop_name_(self):
        with self._choice():
            with self._option():
                self._token('DWITHIN')
            with self._option():
                self._token('BEYOND')
            self._error('expecting one of: BEYOND DWITHIN')

    @graken()
    def _argument_list_(self):
        self._left_paren_()
        with self._optional():
            self._positional_arguments_()
        self._right_paren_()

    @graken()
    def _positional_arguments_(self):

        def block0():
            self._argument_()
        self._positive_closure(block0)

    @graken()
    def _argument_(self):
        with self._choice():
            with self._option():
                self._literal_()
            with self._option():
                self._attribute_name_()
            self._error('no available options')

    @graken()
    def _georoutine_argument_list_(self):
        self._left_paren_()
        self._attribute_name_()
        self._comma_()
        self._geometry_literal_()
        self._right_paren_()

    @graken()
    def _relgeoop_argument_list_(self):
        self._left_paren_()
        self._attribute_name_()
        self._comma_()
        self._geometry_literal_()
        self._comma_()
        self._tolerance_()
        self._right_paren_()

    @graken()
    def _tolerance_(self):
        self._unsigned_numeric_literal_()
        self._comma_()
        self._distance_units_()

    @graken()
    def _distance_units_(self):
        with self._choice():
            with self._option():
                self._token('feet')
            with self._option():
                self._token('meters')
            with self._option():
                self._token('statute miles')
            with self._option():
                self._token('nautical miles')
            with self._option():
                self._token('kilometers')
            self._error('expecting one of: feet kilometers meters nautical miles statute miles')

    @graken()
    def _geometry_literal_(self):
        with self._choice():
            with self._option():
                self._point_tagged_text_()
            with self._option():
                self._linestring_tagged_text_()
            with self._option():
                self._polygon_tagged_text_()
            with self._option():
                self._multipoint_tagged_text_()
            with self._option():
                self._multilinestring_tagged_text_()
            with self._option():
                self._multipolygon_tagged_text_()
            with self._option():
                self._geometrycollection_tagged_text_()
            with self._option():
                self._envelope_tagged_text_()
            self._error('no available options')

    @graken()
    def _point_tagged_text_(self):
        self._token('POINT')
        self._point_text_()

    @graken()
    def _linestring_tagged_text_(self):
        self._token('LINESTRING')
        self._linestring_text_()

    @graken()
    def _polygon_tagged_text_(self):
        self._token('POLYGON')
        self._polygon_text_()

    @graken()
    def _multipoint_tagged_text_(self):
        self._token('MULTIPOINT')
        self._multipoint_text_()

    @graken()
    def _multilinestring_tagged_text_(self):
        self._token('MULTILINESTRING')
        self._multilinestring_text_()

    @graken()
    def _multipolygon_tagged_text_(self):
        self._token('MULTIPOLYGON')
        self._multipolygon_text_()

    @graken()
    def _geometrycollection_tagged_text_(self):
        self._token('GEOMETRYCOLLECTION')
        self._geometrycollection_text_()

    @graken()
    def _point_text_(self):
        with self._choice():
            with self._option():
                self._token('EMPTY')
            with self._option():
                self._token('(')
                self._point_()
                self._token(')')
            self._error('expecting one of: EMPTY')

    @graken()
    def _point_(self):
        self._x_()
        self._token(' ')
        self._y_()

    @graken()
    def _x_(self):
        self._signed_numeric_literal_()

    @graken()
    def _y_(self):
        self._signed_numeric_literal_()

    @graken()
    def _linestring_text_(self):
        with self._choice():
            with self._option():
                self._token('EMPTY')
            with self._option():
                self._token('(')
                self._point_()

                def block0():
                    self._token(',')
                    self._point_()
                self._positive_closure(block0)
                self._token(')')
            self._error('expecting one of: EMPTY')

    @graken()
    def _polygon_text_(self):
        with self._choice():
            with self._option():
                self._token('EMPTY')
            with self._option():
                self._token('(')
                self._linestring_text_()

                def block0():
                    self._token(',')
                    self._linestring_text_()
                self._positive_closure(block0)
                self._token(')')
            self._error('expecting one of: EMPTY')

    @graken()
    def _multipoint_text_(self):
        with self._choice():
            with self._option():
                self._token('EMPTY')
            with self._option():
                self._token('(')
                self._point_text_()

                def block0():
                    self._token(',')
                    self._point_text_()
                self._positive_closure(block0)
                self._token(')')
            self._error('expecting one of: EMPTY')

    @graken()
    def _multilinestring_text_(self):
        with self._choice():
            with self._option():
                self._token('EMPTY')
            with self._option():
                self._token('(')
                self._linestring_text_()

                def block0():
                    self._token(',')
                    self._linestring_text_()
                self._positive_closure(block0)
                self._token(')')
            self._error('expecting one of: EMPTY')

    @graken()
    def _multipolygon_text_(self):
        with self._choice():
            with self._option():
                self._token('EMPTY')
            with self._option():
                self._token('(')
                self._polygon_text_()

                def block0():
                    self._token(',')
                    self._polygon_text_()
                self._positive_closure(block0)
                self._token(')')
            self._error('expecting one of: EMPTY')

    @graken()
    def _geometrycollection_text_(self):
        with self._choice():
            with self._option():
                self._token('EMPTY')
            with self._option():
                self._token('(')
                self._geometry_literal_()

                def block0():
                    self._token(',')
                    self._geometry_literal_()
                self._positive_closure(block0)
                self._token(')')
            self._error('expecting one of: EMPTY')

    @graken()
    def _envelope_tagged_text_(self):
        self._token('ENVELOPE')
        self._envelope_text_()

    @graken()
    def _envelope_text_(self):
        with self._choice():
            with self._option():
                self._token('EMPTY')
            with self._option():
                self._token('(')
                self._westboundlongitude_()
                self._token(',')
                self._eastboundlongitude_()
                self._token(',')
                self._northboundlatitude_()
                self._token(',')
                self._southboundlatitude_()
                self._token(')')
            self._error('expecting one of: EMPTY')

    @graken()
    def _westboundlongitude_(self):
        self._signed_numeric_literal_()

    @graken()
    def _eastboundlongitude_(self):
        self._signed_numeric_literal_()

    @graken()
    def _northboundlatitude_(self):
        self._signed_numeric_literal_()

    @graken()
    def _southboundlatitude_(self):
        self._signed_numeric_literal_()

    @graken()
    def _sql_terminal_character_(self):
        self._sql_language_character_()

    @graken()
    def _sql_language_character_(self):
        with self._choice():
            with self._option():
                self._latin_letter_()
            with self._option():
                self._digit_()
            with self._option():
                self._sql_special_character_()
            self._error('no available options')

    @graken()
    def _latin_letter_(self):
        self._pattern(r'[a-zA-Z]')

    @graken()
    def _digit_(self):
        self._pattern(r'[0-9]')

    @graken()
    def _sql_special_character_(self):
        with self._choice():
            with self._option():
                self._space_()
            with self._option():
                self._double_quote_()
            with self._option():
                self._percent_()
            with self._option():
                self._ampersand_()
            with self._option():
                self._quote_()
            with self._option():
                self._left_paren_()
            with self._option():
                self._right_paren_()
            with self._option():
                self._asterisk_()
            with self._option():
                self._plus_sign_()
            with self._option():
                self._comma_()
            with self._option():
                self._minus_sign_()
            with self._option():
                self._period_()
            with self._option():
                self._solidus_()
            with self._option():
                self._colon_()
            with self._option():
                self._semicolon_()
            with self._option():
                self._less_than_operator_()
            with self._option():
                self._equals_operator_()
            with self._option():
                self._greater_than_operator_()
            with self._option():
                self._question_mark_()
            with self._option():
                self._left_bracket_()
            with self._option():
                self._right_bracket_()
            with self._option():
                self._circumflex_()
            with self._option():
                self._underscore_()
            with self._option():
                self._vertical_bar_()
            with self._option():
                self._left_brace_()
            with self._option():
                self._right_brace_()
            self._error('no available options')

    @graken()
    def _space_(self):
        self._token(' ')

    @graken()
    def _double_quote_(self):
        self._token('"')

    @graken()
    def _percent_(self):
        self._token('%')

    @graken()
    def _ampersand_(self):
        self._token('&')

    @graken()
    def _quote_(self):
        self._token("'")

    @graken()
    def _left_paren_(self):
        self._token('(')

    @graken()
    def _right_paren_(self):
        self._token(')')

    @graken()
    def _asterisk_(self):
        self._token('*')

    @graken()
    def _plus_sign_(self):
        self._token('+')

    @graken()
    def _comma_(self):
        self._token(',')

    @graken()
    def _minus_sign_(self):
        self._token('-')

    @graken()
    def _period_(self):
        self._token('.')

    @graken()
    def _solidus_(self):
        self._token('/')

    @graken()
    def _colon_(self):
        self._token(':')

    @graken()
    def _semicolon_(self):
        self._token(';')

    @graken()
    def _less_than_operator_(self):
        self._token('<')

    @graken()
    def _equals_operator_(self):
        self._token('=')

    @graken()
    def _greater_than_operator_(self):
        self._token('>')

    @graken()
    def _question_mark_(self):
        self._token('?')

    @graken()
    def _left_bracket_(self):
        self._token('[')

    @graken()
    def _right_bracket_(self):
        self._token(']')

    @graken()
    def _circumflex_(self):
        self._token('^')

    @graken()
    def _underscore_(self):
        self._token('_')

    @graken()
    def _vertical_bar_(self):
        self._token('|')

    @graken()
    def _left_brace_(self):
        self._token('{')

    @graken()
    def _right_brace_(self):
        self._token('}')

    @graken()
    def _token_(self):
        with self._choice():
            with self._option():
                self._nondelimiter_token_()
            with self._option():
                self._delimiter_token_()
            self._error('no available options')

    @graken()
    def _nondelimiter_token_(self):
        with self._choice():
            with self._option():
                self._identifier_()
            with self._option():
                self._key_word_()
            with self._option():
                self._unsigned_numeric_literal_()
            self._error('no available options')

    @graken()
    def _key_word_(self):
        self._reserved_word_()

    @graken()
    def _reserved_word_(self):
        with self._choice():
            with self._option():
                self._token('NOT')
            with self._option():
                self._token('AND')
            with self._option():
                self._token('OR')
            with self._option():
                self._token('LIKE')
            with self._option():
                self._token('IS')
            with self._option():
                self._token('NULL')
            with self._option():
                self._token('EXISTS')
            with self._option():
                self._token('DOES-NOT-EXIST')
            with self._option():
                self._token('DURING')
            with self._option():
                self._token('AFTER')
            with self._option():
                self._token('BEFORE')
            with self._option():
                self._token('INCLUDE')
            with self._option():
                self._token('EXCLUDE')
            with self._option():
                self._token('TRUE')
            with self._option():
                self._token('FALSE')
            with self._option():
                self._token('EQUALS')
            with self._option():
                self._token('DISJOINT')
            with self._option():
                self._token('INTERSECTS')
            with self._option():
                self._token('TOUCHES')
            with self._option():
                self._token('CROSSES')
            with self._option():
                self._token('WITHIN')
            with self._option():
                self._token('CONTAINS')
            with self._option():
                self._token('OVERLAPS')
            with self._option():
                self._token('RELATE')
            with self._option():
                self._token('DWITHIN')
            with self._option():
                self._token('BEYOND')
            with self._option():
                self._token('POINT')
            with self._option():
                self._token('LINESTRING')
            with self._option():
                self._token('POLYGON')
            with self._option():
                self._token('MULTIPOINT')
            with self._option():
                self._token('MULTILINESTRING')
            with self._option():
                self._token('MULTIPOLYGON')
            with self._option():
                self._token('GEOMETRYCOLLECTION')
            self._error('expecting one of: AFTER AND BEFORE BEYOND CONTAINS CROSSES DISJOINT DOES-NOT-EXIST DURING DWITHIN EQUALS EXCLUDE EXISTS FALSE GEOMETRYCOLLECTION INCLUDE INTERSECTS IS LIKE LINESTRING MULTILINESTRING MULTIPOINT MULTIPOLYGON NOT NULL OR OVERLAPS POINT POLYGON RELATE TOUCHES TRUE WITHIN')

    @graken()
    def _unsigned_numeric_literal_(self):
        with self._choice():
            with self._option():
                self._exact_numeric_literal_()
            with self._option():
                self._approximate_numeric_literal_()
            self._error('no available options')

    @graken()
    def _exact_numeric_literal_(self):
        with self._choice():
            with self._option():
                self._unsigned_integer_()
                with self._optional():
                    self._period_()
                    with self._optional():
                        self._unsigned_integer_()
            with self._option():
                self._period_()
                self._unsigned_integer_()
            self._error('no available options')

    @graken()
    def _unsigned_integer_(self):

        def block0():
            self._digit_()
        self._positive_closure(block0)

    @graken()
    def _approximate_numeric_literal_(self):
        self._mantissa_()
        self._token('E')
        self._exponent_()

    @graken()
    def _mantissa_(self):
        self._exact_numeric_literal_()

    @graken()
    def _exponent_(self):
        self._signed_integer_()

    @graken()
    def _signed_integer_(self):
        with self._optional():
            self._sign_()
        self._unsigned_integer_()

    @graken()
    def _sign_(self):
        with self._choice():
            with self._option():
                self._plus_sign_()
            with self._option():
                self._minus_sign_()
            self._error('no available options')

    @graken()
    def _delimiter_token_(self):
        with self._choice():
            with self._option():
                self._character_string_literal_()
            with self._option():
                self._sql_special_character_()
            with self._option():
                self._not_equals_operator_()
            with self._option():
                self._greater_than_or_equals_operator_()
            with self._option():
                self._less_than_or_equals_operator_()
            with self._option():
                self._left_bracket_()
            with self._option():
                self._right_bracket_()
            self._error('no available options')

    @graken()
    def _character_string_literal_(self):
        self._quote_()

        def block0():
            self._character_representation_()
        self._closure(block0)
        self._quote_()

    @graken()
    def _character_representation_(self):
        with self._choice():
            with self._option():
                self._nonquote_character_()
            with self._option():
                self._quote_symbol_()
            self._error('no available options')

    @graken()
    def _nonquote_character_(self):
        self._pattern(r"[^']")

    @graken()
    def _quote_symbol_(self):
        self._quote_()
        self._quote_()

    @graken()
    def _not_equals_operator_(self):
        self._token('<>')

    @graken()
    def _greater_than_or_equals_operator_(self):
        self._token('>=')

    @graken()
    def _less_than_or_equals_operator_(self):
        self._token('<=')

    @graken()
    def _identifier_(self):
        self._identifier_start_()

        def block0():
            self._identifier_part_()
        self._closure(block0)

    @graken()
    def _identifier_start_(self):
        self._latin_letter_()

    @graken()
    def _identifier_part_(self):
        with self._choice():
            with self._option():
                self._latin_letter_()
            with self._option():
                self._digit_()
            self._error('no available options')

    @graken()
    def _attribute_name_(self):
        with self._choice():
            with self._option():
                self._identifier_()
            with self._option():
                self._compound_attribute_name_()
            self._error('no available options')

    @graken()
    def _compound_attribute_name_(self):

        def block0():
            self._identifier_()
            self._period_()
        self._positive_closure(block0)
        self._identifier_()


class CqlSemantics(object):
    def sequence_of_search_conditions(self, ast):
        return ast

    def search_condition(self, ast):
        return ast

    def boolean_term(self, ast):
        return ast

    def boolean_factor(self, ast):
        return ast

    def boolean_primary(self, ast):
        return ast

    def predicate(self, ast):
        return ast

    def existence_predicate(self, ast):
        return ast

    def comparison_predicate(self, ast):
        return ast

    def comp_op(self, ast):
        return ast

    def text_predicate(self, ast):
        return ast

    def character_pattern(self, ast):
        return ast

    def null_predicate(self, ast):
        return ast

    def between_predicate(self, ast):
        return ast

    def temporal_predicate(self, ast):
        return ast

    def date_time_expression(self, ast):
        return ast

    def date_time(self, ast):
        return ast

    def full_date(self, ast):
        return ast

    def date_year(self, ast):
        return ast

    def date_month(self, ast):
        return ast

    def date_day(self, ast):
        return ast

    def utc_time(self, ast):
        return ast

    def time_hour(self, ast):
        return ast

    def time_minute(self, ast):
        return ast

    def time_second(self, ast):
        return ast

    def duration(self, ast):
        return ast

    def dur_date(self, ast):
        return ast

    def dur_day(self, ast):
        return ast

    def dur_month(self, ast):
        return ast

    def dur_year(self, ast):
        return ast

    def dur_time(self, ast):
        return ast

    def dur_hour(self, ast):
        return ast

    def dur_minute(self, ast):
        return ast

    def dur_second(self, ast):
        return ast

    def temporal_period(self, ast):
        return ast

    def include_exclude_predicate(self, ast):
        return ast

    def expression(self, ast):
        return ast

    def addition_operator(self, ast):
        return ast

    def multiplication_operator(self, ast):
        return ast

    def function(self, ast):
        return ast

    def function_arguments(self, ast):
        return ast

    def literal(self, ast):
        return ast

    def signed_numeric_literal(self, ast):
        return ast

    def general_literal(self, ast):
        return ast

    def boolean_literal(self, ast):
        return ast

    def routine_invocation(self, ast):
        return ast

    def routine_name(self, ast):
        return ast

    def geoop_name(self, ast):
        return ast

    def bbox_argument_list(self, ast):
        return ast

    def min_X(self, ast):
        return ast

    def min_Y(self, ast):
        return ast

    def max_X(self, ast):
        return ast

    def max_Y(self, ast):
        return ast

    def crs(self, ast):
        return ast

    def relgeoop_name(self, ast):
        return ast

    def argument_list(self, ast):
        return ast

    def positional_arguments(self, ast):
        return ast

    def argument(self, ast):
        return ast

    def georoutine_argument_list(self, ast):
        return ast

    def relgeoop_argument_list(self, ast):
        return ast

    def tolerance(self, ast):
        return ast

    def distance_units(self, ast):
        return ast

    def geometry_literal(self, ast):
        return ast

    def point_tagged_text(self, ast):
        return ast

    def linestring_tagged_text(self, ast):
        return ast

    def polygon_tagged_text(self, ast):
        return ast

    def multipoint_tagged_text(self, ast):
        return ast

    def multilinestring_tagged_text(self, ast):
        return ast

    def multipolygon_tagged_text(self, ast):
        return ast

    def geometrycollection_tagged_text(self, ast):
        return ast

    def point_text(self, ast):
        return ast

    def point(self, ast):
        return ast

    def x(self, ast):
        return ast

    def y(self, ast):
        return ast

    def linestring_text(self, ast):
        return ast

    def polygon_text(self, ast):
        return ast

    def multipoint_text(self, ast):
        return ast

    def multilinestring_text(self, ast):
        return ast

    def multipolygon_text(self, ast):
        return ast

    def geometrycollection_text(self, ast):
        return ast

    def envelope_tagged_text(self, ast):
        return ast

    def envelope_text(self, ast):
        return ast

    def westboundlongitude(self, ast):
        return ast

    def eastboundlongitude(self, ast):
        return ast

    def northboundlatitude(self, ast):
        return ast

    def southboundlatitude(self, ast):
        return ast

    def sql_terminal_character(self, ast):
        return ast

    def sql_language_character(self, ast):
        return ast

    def latin_letter(self, ast):
        return ast

    def digit(self, ast):
        return ast

    def sql_special_character(self, ast):
        return ast

    def space(self, ast):
        return ast

    def double_quote(self, ast):
        return ast

    def percent(self, ast):
        return ast

    def ampersand(self, ast):
        return ast

    def quote(self, ast):
        return ast

    def left_paren(self, ast):
        return ast

    def right_paren(self, ast):
        return ast

    def asterisk(self, ast):
        return ast

    def plus_sign(self, ast):
        return ast

    def comma(self, ast):
        return ast

    def minus_sign(self, ast):
        return ast

    def period(self, ast):
        return ast

    def solidus(self, ast):
        return ast

    def colon(self, ast):
        return ast

    def semicolon(self, ast):
        return ast

    def less_than_operator(self, ast):
        return ast

    def equals_operator(self, ast):
        return ast

    def greater_than_operator(self, ast):
        return ast

    def question_mark(self, ast):
        return ast

    def left_bracket(self, ast):
        return ast

    def right_bracket(self, ast):
        return ast

    def circumflex(self, ast):
        return ast

    def underscore(self, ast):
        return ast

    def vertical_bar(self, ast):
        return ast

    def left_brace(self, ast):
        return ast

    def right_brace(self, ast):
        return ast

    def token(self, ast):
        return ast

    def nondelimiter_token(self, ast):
        return ast

    def key_word(self, ast):
        return ast

    def reserved_word(self, ast):
        return ast

    def unsigned_numeric_literal(self, ast):
        return ast

    def exact_numeric_literal(self, ast):
        return ast

    def unsigned_integer(self, ast):
        return ast

    def approximate_numeric_literal(self, ast):
        return ast

    def mantissa(self, ast):
        return ast

    def exponent(self, ast):
        return ast

    def signed_integer(self, ast):
        return ast

    def sign(self, ast):
        return ast

    def delimiter_token(self, ast):
        return ast

    def character_string_literal(self, ast):
        return ast

    def character_representation(self, ast):
        return ast

    def nonquote_character(self, ast):
        return ast

    def quote_symbol(self, ast):
        return ast

    def not_equals_operator(self, ast):
        return ast

    def greater_than_or_equals_operator(self, ast):
        return ast

    def less_than_or_equals_operator(self, ast):
        return ast

    def identifier(self, ast):
        return ast

    def identifier_start(self, ast):
        return ast

    def identifier_part(self, ast):
        return ast

    def attribute_name(self, ast):
        return ast

    def compound_attribute_name(self, ast):
        return ast


def main(filename, startrule, **kwargs):
    with open(filename) as f:
        text = f.read()
    parser = CqlParser(parseinfo=False)
    return parser.parse(text, startrule, filename=filename, **kwargs)

if __name__ == '__main__':
    import json
    ast = generic_main(main, CqlParser, name='Cql')
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(ast, indent=2))
    print()
